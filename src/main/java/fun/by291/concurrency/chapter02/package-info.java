/**
 * <p>Java 内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程在工作内存中
 * 保存的值是主内存中值的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
 * 等到线程对变量操作完毕之后会将变量的最新值刷新回到主内存。</p>
 *
 * <p>但是何时刷新这个最新值又是随机的。所以就有可能一个线程已经将一个共享变量更新了，但是还没刷新回
 * 主内存，那么这时其他对这个变量进行读写的线程就看不到这个最新值。（还有一种可能就是虽然修改线程已经
 * 将最新值刷新到主内存中去了，但是读线程的工作内存中副本的缓存值还没过期，那么读线程还是会使用这个副本值，
 * 而不是主内存中的最新值）这个就是多 CPU 多线程编程环境下的<b>内存可见性问题。</b></p>
 * <br>
 *
 * <img src="http://cos.by291.fun/img/java-thread.jpg"/>
 *
 * <br>
 * <b>以上图为例，说明 Java 在多线程下的内存可见性问题</b>
 *
 * <p>假设线程 A 和线程 B 同时操作一个共享变量 X，可能会经历下面的过程</p>
 * <ul>
 *     <li>线程 A 首先获取共享变量 X 的值，由于两级 Cache 都没有命中，所以加载主内存中 X 的值
 *     ，假如为 0。然后把 X = 0 的值存到两级缓存，线程 A 修改 X 的值为 1，然后将其写入两级 Cache，
 *     并且刷新到主内存，线程 A 操作完毕后，两级缓存和主内存中的 X 的值都是 1。</li>
 *
 *     <li>线程 B 获取 X 的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了，所以返回 X = 1；
 *     到这里一切都是正常的，因为这时候主内存中 X 也是 1。然后线程 B 修改 X 的值为 2，并将其刷新到两级
 *     缓存中。到这里一切正常。</li>
 *
 *     <li>线程 A 这次又需要修改 X 的值，获取时命中一级缓存，得到 <b>X = 1</b>。到这里问题就出现了。
 *     这就是共享变量的内存不可见问题，也就是线程 B 写入的值对线程 A 不可见。</li>
 * </ul>
 *
 * @author Bystander
 */
package fun.by291.concurrency.chapter02;